<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="内存管理/GCD定时器/NSTimer定时器/AutoreleasePool,">










<meta name="description" content="iOS程序的内存布局iOS程序内存布局从低地址到高地址依次是保留段(保留着供系统使用)、代码段(_TEXT)、数据段(_DATA)、堆(heap)、栈(stack)和内核区。 iOS程序的内存布局如下图所示：   代码段：编译之后的代码 数据段：主要存放字符串常量(比如NSString *str = @”123”)、已初始化数据(已初始化的全局变量、静态变量等)、未初始化数据(未初始化的全局变量、">
<meta name="keywords" content="内存管理&#x2F;GCD定时器&#x2F;NSTimer定时器&#x2F;AutoreleasePool">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS之内存管理探究">
<meta property="og:url" content="http://yoursite.com/2019/07/04/iOS之内存管理探究/index.html">
<meta property="og:site_name" content="平凡的世界">
<meta property="og:description" content="iOS程序的内存布局iOS程序内存布局从低地址到高地址依次是保留段(保留着供系统使用)、代码段(_TEXT)、数据段(_DATA)、堆(heap)、栈(stack)和内核区。 iOS程序的内存布局如下图所示：   代码段：编译之后的代码 数据段：主要存放字符串常量(比如NSString *str = @”123”)、已初始化数据(已初始化的全局变量、静态变量等)、未初始化数据(未初始化的全局变量、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/iOS程序的内存布局示意图.png">
<meta property="og:image" content="http://yoursite.com/images/判断指针是否为TaggedPointer的逻辑示意图.png">
<meta property="og:image" content="http://yoursite.com/images/copy和mutableCopy.png">
<meta property="og:image" content="http://yoursite.com/images/AutoreleasePoolPage底层结构.png">
<meta property="og:image" content="http://yoursite.com/images/AutoreleasePoolPage的详细结构示意图.png">
<meta property="og:updated_time" content="2019-07-04T08:45:42.171Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS之内存管理探究">
<meta name="twitter:description" content="iOS程序的内存布局iOS程序内存布局从低地址到高地址依次是保留段(保留着供系统使用)、代码段(_TEXT)、数据段(_DATA)、堆(heap)、栈(stack)和内核区。 iOS程序的内存布局如下图所示：   代码段：编译之后的代码 数据段：主要存放字符串常量(比如NSString *str = @”123”)、已初始化数据(已初始化的全局变量、静态变量等)、未初始化数据(未初始化的全局变量、">
<meta name="twitter:image" content="http://yoursite.com/images/iOS程序的内存布局示意图.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/04/iOS之内存管理探究/">





  <title>iOS之内存管理探究 | 平凡的世界</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">平凡的世界</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">黄沙百战穿金甲 不破楼兰终不还</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/04/iOS之内存管理探究/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BaoHengLin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="平凡的世界">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS之内存管理探究</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T16:40:14+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/04/iOS之内存管理探究/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/04/iOS之内存管理探究/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/07/04/iOS之内存管理探究/" class="leancloud_visitors" data-flag-title="iOS之内存管理探究">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.3k 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  16 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="iOS程序的内存布局"><a href="#iOS程序的内存布局" class="headerlink" title="iOS程序的内存布局"></a>iOS程序的内存布局</h2><p>iOS程序内存布局从低地址到高地址依次是保留段(保留着供系统使用)、代码段(_TEXT)、数据段(_DATA)、堆(heap)、栈(stack)和内核区。</p>
<p>iOS程序的内存布局如下图所示：</p>
<p><img src="/images/iOS程序的内存布局示意图.png" alt="iOS程序的内存布局示意图.png"></p>
<ul>
<li>代码段：编译之后的代码</li>
<li>数据段：主要存放字符串常量(比如NSString *str = @”123”)、已初始化数据(已初始化的全局变量、静态变量等)、未初始化数据(未初始化的全局变量、静态变量等)</li>
<li>栈：函数调用开销，比如局部变量。分配的内存空间地址越来越小。</li>
<li>堆：通过alloc、malloc、calloc等动态分配的空间，分配的内存空间地址越来越大。</li>
</ul>
<h2 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h2><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储。在没有使用Tagged Pointer之前，NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值。使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：Tag + Data，也就是将数据直接存储在了指针中。当指针不够存储数据时，才会使用动态分配内存的方式来存储数据。objc_msgSend能识别Tagged Pointer，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销。</p>
<p>如何判断一个指针是否为Tagged Pointer？</p>
<p>在mac平台上，如果指针的最低有效位是1，那么该指针为Tagged Pointer，否则就是对象。在iOS平台上，如果指针的最高有效位是1（第64bit），那么该指针为Tagged Pointer。</p>
<p>苹果源码中判断指针是否为Tagged Pointer的逻辑如下图所示：</p>
<p><img src="/images/判断指针是否为TaggedPointer的逻辑示意图.png" alt="判断指针是否为TaggedPointer的逻辑示意图.png"></p>
<h3 id="Tagged-Pointer的相关题目"><a href="#Tagged-Pointer的相关题目" class="headerlink" title="Tagged Pointer的相关题目"></a>Tagged Pointer的相关题目</h3><p>思考以下2段代码会发生什么事？有什么区别？</p>
<p>代码A:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            //加锁</span><br><span class="line">            self.name = [NSString stringWithFormat:@&quot;abcdefghijk&quot;];</span><br><span class="line">            //解锁</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码B：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        dispatch_async(queue, ^&#123;</span><br><span class="line">            //加锁</span><br><span class="line">            self.name = [NSString stringWithFormat:@&quot;abc&quot;];</span><br><span class="line">            //解锁</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码A会崩溃，代码B不会崩溃。代码A崩溃是因为在Setter方法中，由于多条线程对 _name成员变量进行了不止一次Release操作。代码B中的self.name是Tagged Pointer，不是OC对象，不会像普通的OC对象那样调用setter方法执行retain、release操作，而是直接将地址值赋值给了self.name,所以不会崩溃。</p>
<h2 id="OC对象的内存管理"><a href="#OC对象的内存管理" class="headerlink" title="OC对象的内存管理"></a>OC对象的内存管理</h2><p>在iOS中，使用引用计数来管理OC对象的内存。一个新创建的OC对象引用计数默认是1，当引用计数减为0，OC对象就会销毁，释放其占用的内存空间。调用retain会让OC对象的引用计数+1，调用release会让OC对象的引用计数-1。</p>
<p>当调用alloc、new、copy、mutableCopy方法返回了一个对象，在不需要这个对象时，要调用release或者autorelease来释放它。</p>
<h3 id="什么是自动引用计数？"><a href="#什么是自动引用计数？" class="headerlink" title="什么是自动引用计数？"></a>什么是自动引用计数？</h3><p>&emsp;&emsp;顾明思义，自动引用计数（ARC，Automatic Reference Counting）是指内存管理中对引用采取自动计数的技术。以下摘自苹果的官方说明：</p>
<p>&emsp;&emsp;在Objective-C中采用Automatic Reference Counting（ARC）机制，让编译器来进行内存管理。在新一代Apple LLVM编译器中设置ARC为有效状态，就无需再次键入retain或者release代码，这在降低程序崩溃、内存泄漏等风险的同时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。</p>
<p>&emsp;&emsp;换言之，若满足以下条件，就无需手动输入retain和release代码了。</p>
<ul>
<li>使用Xcode4.2或以上版本</li>
</ul>
<ul>
<li>使用LLVM编译器3.0或以上版本</li>
</ul>
<ul>
<li>编译器选项中设置ARC有效</li>
</ul>
<p>&emsp;&emsp;在以上条件下编译源代码时，编译器将自动进行内存管理。</p>
<h3 id="引用计数的工作原理（思考方式）"><a href="#引用计数的工作原理（思考方式）" class="headerlink" title="引用计数的工作原理（思考方式）"></a>引用计数的工作原理（思考方式）</h3><p>&emsp;&emsp;内存管理的思考方式如下：</p>
<ul>
<li>（1）自己生成的对象，自己所持有；</li>
<li>（2）非自己生成的对象，自己也能持有；</li>
<li>（3）不再需要自己持有的对象时，释放；</li>
<li>（4）非自己持有的对象，无法释放。</li>
</ul>
<p>&emsp;&emsp;对象操作与Objective-C方法的对应如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">对象操作</th>
<th style="text-align:left">Objective-C 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">生成并持有对象</td>
<td style="text-align:left">alloc/new/copy/mutableCopy等方法</td>
</tr>
<tr>
<td style="text-align:left">持有对象</td>
<td style="text-align:left">retain 方法 </td>
</tr>
<tr>
<td style="text-align:left">释放对象</td>
<td style="text-align:left">release 方法</td>
</tr>
<tr>
<td style="text-align:left">废弃对象</td>
<td style="text-align:left">dealloc 方法</td>
</tr>
</tbody>
</table>
<p>【注意】Objective-C内存管理中的alloc/retain/release/dealloc方法分别指代NSSObject类的alloc类方法、retain实例方法、release实例方法和dealloc实例方法。</p>
<h2 id="copy-VS-MutableCopy、浅拷贝-VS-深拷贝"><a href="#copy-VS-MutableCopy、浅拷贝-VS-深拷贝" class="headerlink" title="copy VS MutableCopy、浅拷贝 VS 深拷贝"></a>copy VS MutableCopy、浅拷贝 VS 深拷贝</h2><p>copy的目的是为了产生一个副本对象，和源对象互补影响。也就是改变了源对象，不会影响副本对象；修改了副本对象，不会影响源对象。</p>
<p>iOS提供了2个拷贝方法copy和mutableCopy，其中copy是不可变拷贝，产生的是不可变副本；mutableCopy是可变拷贝，产生的是可变副本。</p>
<ul>
<li><p>浅拷贝：指针拷贝，不拷贝内容，没有产生新对象，只是使当前对象引用计数加1。</p>
</li>
<li><p>深拷贝：内容拷贝，产生了新对象。比如mutableCopy</p>
</li>
</ul>
<p><img src="/images/copy和mutableCopy.png" alt="copy和mutableCopy.png"></p>
<p>【总结】如果源对象是不可变对象，那么该对象调用copy是浅拷贝，调用mutableCopy是深拷贝。<strong>如果源对象是可变对象，那么不管调用copy还是mutableCopy，都是深拷贝</strong>。</p>
<h2 id="属性修饰词assign-retain-strong-copy"><a href="#属性修饰词assign-retain-strong-copy" class="headerlink" title="属性修饰词assign/retain/strong/copy"></a>属性修饰词assign/retain/strong/copy</h2><p>assign：修饰基本数据类型，在生成的setter内直接赋值</p>
<p>retain：在生成的setter内将新值retain保留，将旧值release释放掉。</p>
<p>strong：数组和字典类型的属性一般用strong修饰。</p>
<p>copy：在生成的setter内新值调用copy，将旧值release释放掉。copy修饰的属性一定要是不可变的对象，否则可能会出错。一般来说字符串类型的属性都是用copy来修饰。</p>
<h2 id="引用计数的存储"><a href="#引用计数的存储" class="headerlink" title="引用计数的存储"></a>引用计数的存储</h2><p>在64bit中，引用计数可以直接存储在优化过的isa指针中，但是如果isa指针中的19bit存储空间存储不下时，就存储在SideTable类中 RefcountMap refcnts散列表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct SideTable &#123;</span><br><span class="line">    spinlock_t slock;</span><br><span class="line">    RefcountMap refcnts;//存放着对象引用计数的散列表</span><br><span class="line">    weak_table_t weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="weak指针的实现原理"><a href="#weak指针的实现原理" class="headerlink" title="weak指针的实现原理"></a>weak指针的实现原理</h2><p>修饰指针的修饰词包括<strong>strong、</strong>weak、__unsafe_unretained这三个修饰词。</p>
<ul>
<li>__strong：强引用</li>
<li>__weak：弱引用，当指针指向的对象销毁之后，会将该指针置为nil，防止产生野指针</li>
<li>__unsafe_unretained：弱引用，当指针指向的对象销毁之后，不会将该指针置为nil，会产生野指针，不安全。</li>
</ul>
<p>那么__weak的实现原理是怎样的呢？</p>
<p>我们可以通过查看objc源码来研究__weak的实现原理。(objc-&gt;Source-&gt;NSObject.mm-&gt;dealloc)</p>
<p>__weak的实现原理:程序运行过程中Runtime将对象的弱引用存储到弱引用哈希表weak_table_t weak_table中，当弱引用指针指向的对象销毁时，通过相应计算获取当前对象所对应的弱引用表，并将弱引用表中存储的所有弱引用都清除掉，也就是置为nil。</p>
<h2 id="autoreleasepool的实现原理"><a href="#autoreleasepool的实现原理" class="headerlink" title="autoreleasepool的实现原理"></a>autoreleasepool的实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动释放池的主要底层数据结构是：__AtAutoreleasePool、AutoreleasePoolPage。调用了autorelease的对象最终都是通过AutoreleasePoolPage对象来管理的。</p>
<p>AutoreleasePoolPage的底层结构的成员变量示意图如下：</p>
<p><img src="/images/AutoreleasePoolPage底层结构.png" alt="AutoreleasePoolPage底层结构.png"></p>
<p>各个成员变量的含义如下：</p>
<ul>
<li>magic:用来检验AutoreleasePoolPage的结构是否完整</li>
<li>next:指向最新添加的autorelease对象的下一个位置</li>
<li>thread:指向当前线程</li>
<li>parent：指向父节点，第一个节点的parent值为nil</li>
<li>child:指向子节点，最后一个节点的child值为nil</li>
<li>depth:代表深度，从0开始，往后递增1</li>
<li>hiwat:表示high water mark</li>
</ul>
<p>AutoreleasePoolPage的底层详细结构示意图如下：</p>
<p><img src="/images/AutoreleasePoolPage的详细结构示意图.png" alt="AutoreleasePoolPage的详细结构示意图.png"></p>
<p>每个AutoreleasePoolPage对象占用4096字节内存，除了用来存放它内部的成员变量，剩下的空间用来存放autorelease对象的地址。其中的child变量存储着下一个AutoreleasePoolPage的地址值，parent变量存储着上一个AutoreleasePoolPage的地址值。所有的AutoreleasePoolPage对象通过双向链表的形式连接在一起。</p>
<p>autoreleasepool的本质是在花括号的开头调用了 atautoreleasepoolobj = objc_autoreleasePoolPush();函数，在花括号的结尾处调用了objc_autoreleasePoolPop(atautoreleasepoolobj);函数。</p>
<p>调用objc_autoreleasePoolPush方法时会将一个POOL_BOUNDARY压入栈中作为边界标识，并返回其存放的内存地址。此外会将所有的autorelease对象(对象调用了autorelease方法)的地址值依次存放在接下来的地址空间中，当一个AutoreleasePoolPage的空间被占满时，就会创建下一个AutoreleasePoolPage对象，通过parent和child指针连接成双向链表。</p>
<p>当调用objc_autoreleasePoolPop函数时，将当初入栈时存放的POOL_BOUNDARY传入Pop函数，并从最后一个入栈（栈顶）的autorelease对象开始依次对它们调用release方法，直到POOL_BOUNDARY这个边界为止。</p>
<h2 id="RunLoop和Autorelease"><a href="#RunLoop和Autorelease" class="headerlink" title="RunLoop和Autorelease"></a>RunLoop和Autorelease</h2><p>打印主线程的RunLoop</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;,[NSRunLoop mainRunLoop]);</span><br></pre></td></tr></table></figure>
<p>从打印的结果，我们可以发现以下两个与自动释放池相关的observer：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&lt;CFRunLoopObserver 0x6000012705a0 [0x1042deae8]&gt;&#123;valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x106dd987d), context = &lt;CFArray 0x600002d64cc0 [0x1042deae8]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffc62802058&gt;\n)&#125;&#125;&quot;,</span><br><span class="line"> </span><br><span class="line"> &quot;&lt;CFRunLoopObserver 0x600001270460 [0x1042deae8]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x106dd987d), context = &lt;CFArray 0x600002d64cc0 [0x1042deae8]&gt;&#123;type = mutable-small, count = 1, values = (\n\t0 : &lt;0x7ffc62802058&gt;\n)&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>iOS在主线程的Runloop中注册了2个Observer，第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()。第2个Observer一方面监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()；另一方面监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()。其实autoreleasepool对象就是在当前的RunLoop进入休眠（kCFRunLoopBeforeWaiting）之前调用objc_autoreleasePoolPop()的时候被release的。</p>
<h2 id="内存管理总结："><a href="#内存管理总结：" class="headerlink" title="内存管理总结："></a>内存管理总结：</h2><ol>
<li>使用CADisplayLink、NSTimer有什么注意点？</li>
</ol>
<p>CADispalyLink、NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会导致循环引用。另一个问题就是可能存在定时器不准时的问题。</p>
<p>2.简述内存的几大区域</p>
<p>3.谈谈对iOS内存管理的理解</p>
<p>4.autorelease对象在什么时候会被release的？</p>
<p>iOS在主线程的Runloop中注册了2个Observer，第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()。第2个Observer一方面监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()；另一方面监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()。其实autoreleasepool对象就是在当前的RunLoop进入休眠（kCFRunLoopBeforeWaiting）之前调用objc_autoreleasePoolPop()的时候被release的。</p>
<p>5.方法里有局部对象，出了方法后会立即释放吗？</p>
<p>6.ARC都帮我们做了什么？</p>
<p>ARC是LLVM和Runtime系统相互协作的一个结果。开启ARC后，LLVM编译器自动添加了retain、release等有关内存管理的代码。此外，程序运行过程中Runtime将使用__weak修饰的对象的弱引用存储到弱引用哈希表weak_table_t weak_table中，当弱引用指针指向的对象销毁时，通过相应计算获取当前对象所对应的弱引用表，并将弱引用表中存储的所有弱引用都清除掉，也就是置为nil。</p>
<p>7.weak指针的实现原理？</p>
<p>程序运行过程中Runtime将对象的弱引用存储到弱引用哈希表weak_table_t weak_table中，当弱引用指针指向的对象销毁时，通过相应计算获取当前对象所对应的弱引用表，并将弱引用表中存储的所有弱引用都清除掉，也就是置为nil。</p>
<h2 id="NSTimer、CADisplayLink的循环引用问题"><a href="#NSTimer、CADisplayLink的循环引用问题" class="headerlink" title="NSTimer、CADisplayLink的循环引用问题"></a>NSTimer、CADisplayLink的循环引用问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">@property (nonatomic, strong) CADisplayLink *link;</span><br><span class="line">@property (nonatomic, strong) NSTimer *timer;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    //CADisplayLink，也是一种定时器，保证调用频率和屏幕的刷帧频率一致，60FPS</span><br><span class="line">    //CADisplayLink定时器也会产生循环引用</span><br><span class="line">    self.link = [CADisplayLink displayLinkWithTarget:self selector:@selector(linkTest)];</span><br><span class="line">    [self.link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    </span><br><span class="line">    //使用scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:会产生循环引用。</span><br><span class="line">    //__weak typeof(self) weakSelf = self;//不能解决NSTimer循环引用问题。可以解决block的循环引用。</span><br><span class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTest) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (void)linkTest</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    //定时器都要调用invalidate方法来销毁定时器，否则会崩溃</span><br><span class="line">    [self.link invalidate];</span><br><span class="line">    [self.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>以上代码中定时器CADisplayLink和NSTimer都产生循环引用的问题，原因是CADisplayLink、NSTimer会对target产生强引用，同时target又对它们产生强引用，从而导致了循环引用。分析如下：</p>
<ul>
<li>self-&gt;(强引用)link -&gt;(强引用)target:self。</li>
<li>self-&gt;(强引用)timer-&gt;(强引用)target:self。</li>
</ul>
<p>解决方法1：使用scheduledTimerWithTimeInterval: repeats: block:方法替代scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:方法</p>
<p>//打破循环引用的原因：self-&gt;(强引用)timer-&gt;(强引用)block-&gt;(弱引用)self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    [weakSelf timerTest];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>解决方法2：自定义中间代理类+消息转发机制</p>
<p>创建一个基于NSObject的类HLproxy</p>
<p>HLproxy.h代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface HLproxy : NSObject</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>HLproxy.m代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;HLproxy.h&quot;</span><br><span class="line">@implementation HLproxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    HLproxy *proxy = [[HLproxy alloc]init];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> 消息转发机制的三大阶段：(1)消息发送阶段,(2)动态方法解析阶段,(3)消息转发阶段</span><br><span class="line"> */</span><br><span class="line">//消息转发阶段</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    //objc_msgSend(self.target,aSelector);</span><br><span class="line">    return self.target;</span><br><span class="line">&#125;</span><br><span class="line">//- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</span><br><span class="line">//&#123;</span><br><span class="line">//    return nil;</span><br><span class="line">//&#125;</span><br><span class="line">//- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">//&#123;</span><br><span class="line">//    </span><br><span class="line">//&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>ViewController.m中代码做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[HLproxy proxyWithTarget:self] selector:@selector(timerTest) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure>
<p>同理，CADisplayLink定时器的循环引用问题也可以通过方法2来解决</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.link = [CADisplayLink displayLinkWithTarget:[HLproxy proxyWithTarget:self] selector:@selector(linkTest)];</span><br></pre></td></tr></table></figure>
<p>解决方法3：使用代理对象(NSProxy)</p>
<p>创建继承自NSProxy的类HLBestProxy</p>
<p>HLBestProxy.h代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//继承自 NSProxy</span><br><span class="line">@interface HLBestProxy : NSProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target;</span><br><span class="line">@property (nonatomic, weak) id target;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>HLBestProxy.m代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;HLBestProxy.h&quot;</span><br><span class="line">@implementation HLBestProxy</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    //NSProxy没有init方法，不需要调用init。</span><br><span class="line">    HLBestProxy *proxy = [HLBestProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    return proxy;</span><br><span class="line">&#125;</span><br><span class="line">//如果当前类中没有查找到要调用的方法，那么不会去父类当中去查找该方法，也不会进入消息动态解析阶段，而是直接进入到消息转发阶段。其执行效率更高。</span><br><span class="line">//NSProxy与NSObject类是同级别的，都是基类。NSProxy是专门用来做消息转发的，</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    //返回 方法签名</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    //调用方法</span><br><span class="line">    [invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>方法2和方法3乍看起来好像差不多，其实，方法3与方法2相比，执行效率更高。因为NSProxy与NSObject类是同级别的类，都是基类。NSProxy是专门用来做消息转发处理的类，在调用方法过程中，如果当前类HLBestProxy中没有查找到要调用的方法，那么它不会去其父类NSProxy当中去查找是否存在该方法，也不会进入消息动态解析阶段，而是直接进入到消息转发阶段，其执行效率更高，所以推荐使用方法3这种通过NSProxy类创建代理对象的解决方法。</p>
<h2 id="NSProxy"><a href="#NSProxy" class="headerlink" title="NSProxy"></a>NSProxy</h2><p>NSProxy的底层实现源码可以查看<a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep Base</a>Foundation中的NSProxy.m中的源码。</p>
<p>下面代码输出结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ViewController *vc = [[ViewController alloc]init];</span><br><span class="line">HLproxy *proxy1 = [HLproxy proxyWithTarget:vc];</span><br><span class="line">HLBestProxy *proxy2 = [HLBestProxy proxyWithTarget:vc];</span><br><span class="line">NSLog(@&quot;%d %d&quot;,[proxy1 isKindOfClass:[ViewController class]],[proxy2 isKindOfClass:[ViewController class]]);</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-07-03 11:59:31.515103+0800 内存管理_NSTimer[47838:2484092] 0 1</span><br></pre></td></tr></table></figure>
<p>我们看到[proxy2 isKindOfClass:[ViewController class]]的结果是1，为什么会这样呢？因为proxy2的类对象HLBestProxy继承自NSProxy，HLBestProxy内部自动实现了消息转发操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    //返回 方法签名</span><br><span class="line">    return [self.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    //调用方法</span><br><span class="line">    [invocation invokeWithTarget:self.target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终代码[proxy2 isKindOfClass:[ViewController class]]转化为[vc isKindOfClass:[ViewController class]]，所以结果是1。</p>
<h2 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h2><p>由于NSTimer定时器依赖于RunLoop，如果RunLoop的任务过于繁重，那么可能将导致NSTimer定时器不准时。那么怎么做才能保证定时器准时呢？</p>
<p>可以使用<strong>GCD定时器</strong>,GCD定时器是跟系统内核直接挂钩，不依赖于RunLoop，所以GCD定时器非常准时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    NSLog(@&quot;----begin&quot;);</span><br><span class="line">    //串行队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;timer&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    //创建GCD定时器</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    //设置时间</span><br><span class="line">    NSTimeInterval start = 2.0;//2秒后开始执行</span><br><span class="line">    NSTimeInterval interval = 1.0;//每隔一秒执行</span><br><span class="line">    dispatch_source_set_timer(timer, dispatch_time(DISPATCH_TIME_NOW, start * NSEC_PER_SEC), interval * NSEC_PER_SEC, 0);</span><br><span class="line">    //设置回调</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;每隔1秒打印---1111&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //启动定时器</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">    self.timer = timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于项目中可能有多出需要使用该GCD定时器，所以我们可以将GCD定时器封装成专门的定时器类。<a href="https://github.com/baohenglin/GCD-Timer" target="_blank" rel="noopener">GCD定时器完整封装</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/内存管理-GCD定时器-NSTimer定时器-AutoreleasePool/" rel="tag"># 内存管理/GCD定时器/NSTimer定时器/AutoreleasePool</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/02/iOS之多线程探究/" rel="next" title="iOS之多线程探究">
                <i class="fa fa-chevron-left"></i> iOS之多线程探究
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/09/一份全面提升计算机技术及素养的书单/" rel="prev" title="一份全面提升计算机技术及素养的书单">
                一份全面提升计算机技术及素养的书单 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BaoHengLin</p>
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里；    不积小流，无以成江海</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/baohenglin" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1693288015@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#iOS程序的内存布局"><span class="nav-number">1.</span> <span class="nav-text">iOS程序的内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tagged-Pointer"><span class="nav-number">2.</span> <span class="nav-text">Tagged Pointer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tagged-Pointer的相关题目"><span class="nav-number">2.1.</span> <span class="nav-text">Tagged Pointer的相关题目</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OC对象的内存管理"><span class="nav-number">3.</span> <span class="nav-text">OC对象的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是自动引用计数？"><span class="nav-number">3.1.</span> <span class="nav-text">什么是自动引用计数？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用计数的工作原理（思考方式）"><span class="nav-number">3.2.</span> <span class="nav-text">引用计数的工作原理（思考方式）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#copy-VS-MutableCopy、浅拷贝-VS-深拷贝"><span class="nav-number">4.</span> <span class="nav-text">copy VS MutableCopy、浅拷贝 VS 深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性修饰词assign-retain-strong-copy"><span class="nav-number">5.</span> <span class="nav-text">属性修饰词assign/retain/strong/copy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用计数的存储"><span class="nav-number">6.</span> <span class="nav-text">引用计数的存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak指针的实现原理"><span class="nav-number">7.</span> <span class="nav-text">weak指针的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#autoreleasepool的实现原理"><span class="nav-number">8.</span> <span class="nav-text">autoreleasepool的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop和Autorelease"><span class="nav-number">9.</span> <span class="nav-text">RunLoop和Autorelease</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存管理总结："><span class="nav-number">10.</span> <span class="nav-text">内存管理总结：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSTimer、CADisplayLink的循环引用问题"><span class="nav-number">11.</span> <span class="nav-text">NSTimer、CADisplayLink的循环引用问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSProxy"><span class="nav-number">12.</span> <span class="nav-text">NSProxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCD定时器"><span class="nav-number">13.</span> <span class="nav-text">GCD定时器</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BaoHengLin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">40.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>




  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'dJpP7Hi7hM4Kr2srjNyDGWdo-gzGzoHsz',
        appKey: '6RSXBimGjY0zY3Qs1B0lkgGz',
        placeholder: '欢迎留言',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("dJpP7Hi7hM4Kr2srjNyDGWdo-gzGzoHsz", "6RSXBimGjY0zY3Qs1B0lkgGz");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
